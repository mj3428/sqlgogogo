### 创建索引语法:
```

CREATE[UNIQUE|FULLTEXT|SPATIAL]INDEX index_name
[USING index_type]
ON tbl_name(index_col_name,...)

index_col_name:
  col_name[(length)][ASC|DESC]
```
如：
```
mysql> create index cityname on city (city(10))
```
### 删除索引：
```
DROP INDEX index_name ON tbl_name
```

## 设计原则
- 最适合索引的列是出现在WHERE子句中的列，或者连接子句中指定的列，而不是出现在SELECT后选择列表中的列  
- 使用唯一索引  
- 使用短索引。例如，有一个CHAR(200)列，如果再前10个或20个字符内，多数值是唯一的，那么就不要对整个列进行索引。
  对前10个或20个字符进行索引能够节省大量索引空间，也可能会使查询更快。更重要的是，对于较短的键值，
  索引告诉缓存中的块能容纳更多的键值。
- 利用最左前缀。  
- 不要过度索引。不要以为索引“越多越好”。每个额外的索引都要占用额外的磁盘空间，并降低写操作的性能。有时修改表，
  连同索引要及时更新，那么所花的时间越长。  
- InnoDB存储引擎的表，记录默认会按照一定的顺序保存，如果有明确定义的主键，则按照主键顺序保存。如果没有主键，
  但是有唯一索引，那么就按照唯一索引的顺序保存。如果既没有主键又没有唯一索引，那么表中会自动生成一个内部列，
  按照这个列的顺序保存。按照主键或内部列进行的访问是最快的，所以InnoDB尽量自己指定主键。

### BTREE索引与HASH索引
MEMORY存储引擎的表可以使用BTREE索引和HASH索引  
*注：HASH索引的局限*  
* 只用于使用=或者<=>操作符的等式比较
* 优化器不能使用HASH索引来加速ORDER BY操作
* MYSQL不能确定在两个值之间约有多少行。如果将一个MyISAM表改为HASH索引的MEMORY表，会影响一些查询的执行效率
* 只能使用整个关键字来搜索一行
而对于BTREE索引，当使用>,<,>=,<=,BTWEEN,!=,<>,或者LIKE'pattern'（其中'pattern'不以通配符开始）操作符时，都可以使用相关列上的索引。  
